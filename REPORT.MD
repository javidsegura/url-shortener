IMPROVEMENTS
URL Shortener has a large series of upgrades added since the first assignment. These improvements have mostly concentrated around the dev-ops pipeline,cloud-services security, monitoring, tests and developer experience (connection scripts, modularity, health checks, gemini).
Dev-Ops pipeline
I have integrated a complete CI/CD that deploys our code changes into our cloud environment automatically. It goes through an extensive continuous integration pipeline that among other things, checks the modifications to the repo do not break existing functionality and adhere to the repository coding standards (more info about this later). For continuous delivery I have replicated the prior AWS cloud environment into Azure. This makes the project multi-cloud, bringing resilience and minimal downtime at the expense of higher technical overhead and costs. I have also rolled back from a gitflow repository strategy to trunk-based model. This decision is due to the significant unnecessary overhead that brings the former approach.
I also switched to uv as our package-installation provider (contrary to pip). In addition to adding a cacheable layer in the dockerfile images I saw a decrease in build time of 87.5% (from 4 minutes to 30 seconds)

Cloud-services
Besides the integration of the multi-cloud strategy previously mentioned, I have also maintained AWS’s staging environment which allows us to debug in an environment that mirrors production more closely, thus capturing errors earlier in the process. However, this comes at the expenditure of increased infrastructure costs and longer development time. Regarding container registry, I have decided to stick to Docker’s standard Docker Hub due to some recurrent issues with Azure’s service.
Security
In order to make sure that deployment from local host to production is minimally exposed I have integrated several security best practices. I have used environmental variables and github secrets to make sure credentials are never exposed to malicious actors. Besides that, I have a pre-commit hook that asserts no private keys are never committed (i.e., the hook fails the commit if the private key is committed). I also integrated a custom environmental variable script that checks that all the environmental variables needed for the selected cloud provider and environment (e.g., aws locally vs azure in prod).
In the CI pipeline I also have static security checkers that make sure security best practices are implemented. For example, in one failed CI, I saw how the analyzer demanded to use the more secure cryptography library for random number generation (used in one of the strategies of the shortening service) instead of random library.
Finally, setting most patterns for secrets naming into gitignore is a simple but effective strategy that minimizes uncareful commits of secrets.
Tests
The tests suite has been significantly expanded. I currently have several different types of tests used both in the pre-commit as well as in the CI pipeline. I added integration, load (with k6), unit (expanded), smoke and regression tests. These expanded suites of tests have already proven to be extremely useful. They have allowed me to capture early subtle errors that could have a serious impact in a production setting. I currently have over 85% test coverage. Coverage is a requirement of the pipeline which fails when having less than 70% of total test coverage.
While not strictly a test, we have added another mechanism to assert the uptime of our app. I have created two endpoints under the health router: /ping and /dependencies. These capture basic information about the status of the app and allow a deployment if the health checks fail. I have also added health checks into most docker services. This allows to make sure that poisonous services do not get deployed and provide the false impression of a successful deployment.
Overall, we have tried to provide an ecosystem of tests and health checks that try to bring bugs into observation as soon as possible. We believe adopting a fail-fast approach, allows us to minimize the probabilities of having unexpected production failures.
Developer Experience
In order to make the iterative development earlier I have adopted several best practices. First, I have registered most ideas for improvement into the issues tab of github. This provides a central place of ground truth data that can be used to provide the clear steps ahead.
For debugging in production, besides telemetry, I have developed a series of scripts that seamlessly create ssh tunnels from localhost into the server. This proved to be super useful when debugging staging environments, database and the docker compose as a whole.
The repository has significantly grown in length. Currently, it is around 13k lines of code. Thus the need to have substantial modularity is imperative. With respect to the prior version, we have created the /deployment directory. Here are all the configurations of the different docker compose (both base + environment-specific) as well as the telemetry and reverse proxy configuration.
